use std::sync::Arc;
use sea_orm::DatabaseConnection;
use utoipa_axum::router::OpenApiRouter;
use utoipa_axum::routes;
use axum::{routing::{get, post}, Router, extract::{State, Path, Json, Query}, response::IntoResponse};
use common::base::page::PaginatedResponse;
use crate::service::{{ table_name }}::{{ service_name }};
use system_model::request::{{ table_name }}::{Create{{ request_model_name }}, Update{{ request_model_name }}, PaginatedKeywordRequest};
use system_model::response::{{ table_name }}::{{ response_model_name }};

pub async fn {{ table_name }}_router(db: Arc<DatabaseConnection>) -> OpenApiRouter {
    let {{ table_name }}_service = {{ service_name }}::get_instance(db).await;

    OpenApiRouter::new()
        .routes(routes!(create))
        .routes(routes!(update))
        .routes(routes!(delete))
        .routes(routes!(get_by_id))
        .routes(routes!(list))
        .routes(routes!(page))
        .with_state(AppState { {{ table_name }}_service })
}

pub async fn {{ table_name }}_route(db: Arc<DatabaseConnection>) -> Router {
    let {{ table_name }}_service = {{ service_name }}::get_instance(db).await;

    Router::new()
        .route("/create", post(create))
        .route("/update", post(update))
        .route("/delete/{id}", post(delete))
        .route("/get/{id}", get(get_by_id))
        .route("/list", get(list))
        .route("/page", get(page))
        .with_state(AppState { {{ table_name }}_service })
}

#[derive(Clone)]
struct AppState {
    {{ table_name }}_service: Arc<{{ service_name }}>,
}

#[utoipa::path(
    post,
    path = "/create",
    operation_id = "{{ table_name }}_create",
    request_body(content = Create{{ request_model_name }}, description = "create", content_type = "application/json"),
    responses(
        (status = 200, description = "id", body = i64, example = json!(1))
    ),
    tag = "{{ table_name }}"
)]
async fn create(
    State(state): State<AppState>,
    Json(payload): Json<Create{{ request_model_name }}>,
) -> Result<Json<i64>, axum::http::StatusCode> {
    let id = state.{{ table_name }}_service.create(payload)
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(id))
}

#[utoipa::path(
    post,
    path = "/update",
    operation_id = "{{ table_name }}_update",
    request_body(content = Update{{ request_model_name }}, description = "update", content_type = "application/json"),
    responses(
        (status = 204, description = "update")
    ),
    tag = "{{ table_name }}"
)]
async fn update(
    State(state): State<AppState>,
    Json(payload): Json<Update{{ request_model_name }}>,
) -> Result<impl IntoResponse, axum::http::StatusCode> {
    state.{{ table_name }}_service.update(payload)
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(axum::http::StatusCode::NO_CONTENT)
}

#[utoipa::path(
    post,
    path = "/delete/{id}",
    operation_id = "{{ table_name }}_delete",
    params(
        ("id" = i64, Path, description = "id")
    ),
    responses(
        (status = 204, description = "delete")
    ),
    tag = "{{ table_name }}"
)]
async fn delete(
    State(state): State<AppState>,
    Path(id): Path<i64>,
) -> Result<impl IntoResponse, axum::http::StatusCode> {
    state.{{ table_name }}_service.delete(id)
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(axum::http::StatusCode::NO_CONTENT)
}

#[utoipa::path(
    get,
    path = "/get/{id}",
    operation_id = "{{ table_name }}_get_by_id",
    params(
        ("id" = i64, Path, description = "id")
    ),
    responses(
        (status = 200, description = "get by id", body = Option<{{ response_model_name }}>)
    ),
    tag = "{{ table_name }}"
)]
async fn get_by_id(
    State(state): State<AppState>,
    Path(id): Path<i64>,
) -> Result<Json<Option<{{ response_model_name }}>>, axum::http::StatusCode> {
    let {{ table_name }} = state.{{ table_name }}_service.get_by_id(id)
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json({{ table_name }}))
}

#[utoipa::path(
    get,
    path = "/page",
    operation_id = "{{ table_name }}_page",
    params(
        ("page" = u64, Query, description = "page number"),
        ("page_size" = u64, Query, description = "page size"),
        ("keyword" = Option<String>, Query, description = "keyword")
    ),
    responses(
        (status = 200, description = "get page", body = {{ response_model_name }})
    ),
    tag = "{{ table_name }}"
)]
async fn page(
    State(state): State<AppState>,
    Query(params): Query<PaginatedKeywordRequest>,
) -> Result<Json<PaginatedResponse<{{ response_model_name }}>>, axum::http::StatusCode> {
    let paginated = state.{{ table_name }}_service.get_paginated(params)
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(paginated))
}

#[utoipa::path(
    get,
    path = "/list",
    operation_id = "{{ table_name }}_list",
    responses(
        (status = 200, description = "list all", body = Vec<{{ response_model_name }}>)
    ),
    tag = "{{ table_name }}"
)]
async fn list(State(state): State<AppState>) -> Result<Json<Vec<{{ response_model_name }}>>, axum::http::StatusCode> {
    let list = state.{{ table_name }}_service.list()
        .await
        .map_err(|_| axum::http::StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(list))
}